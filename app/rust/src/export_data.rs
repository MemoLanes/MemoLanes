use crate::journey_vector::JourneyVector;
use crate::storage::RawCsvRow;
use actix_web::cookie::time::{Duration, OffsetDateTime};
use anyhow::{Context, Ok, Result};
use auto_context::auto_context;
use csv::Reader;
use geo_types::Point;
use gpx::{Gpx, GpxVersion, Metadata, Track, TrackSegment, Waypoint};
use kml::{Kml, KmlDocument, KmlWriter};
use std::{
    collections::HashMap,
    io::{Seek, Write},
};

// TODO: Pull in more metadata to the exported files, e.g. timestamp, note, etc
// For most things, we could put them as custom attributes. The timestamp is a
// bit annoying. Ideally I don't want to fake data (e.g. generating timestamps
// for all points based on begin and end time). So maybe also treat them as
// custom attributes or just add timestamp for the first and last point if possible.
fn write_gpx_with_segments<T: Write + Seek>(
    segments: Vec<TrackSegment>,
    name: Option<String>,
    writer: &mut T,
) -> Result<()> {
    if segments.is_empty() {
        anyhow::bail!("No track segments");
    }

    let track = Track {
        name: Some("MemoLanes Track".to_string()),
        comment: None,
        description: None,
        source: None,
        links: vec![],
        type_: None,
        number: None,
        segments,
    };

    let gpx = Gpx {
        version: GpxVersion::Gpx11,
        creator: Some("MemoLanes".to_string()),
        metadata: Some(Metadata {
            name,
            ..Default::default()
        }),
        waypoints: vec![],
        tracks: vec![track],
        routes: vec![],
    };

    gpx::write(&gpx, writer)?;
    Ok(())
}

#[auto_context]
pub fn journey_vector_to_gpx_file<T: Write + Seek>(
    journey_vector: &JourneyVector,
    writer: &mut T,
) -> Result<()> {
    let mut segments = Vec::new();

    for track_segment in &journey_vector.track_segments {
        let mut points = Vec::new();
        track_segment.track_points.iter().for_each(|point| {
            points.push(Waypoint::new(Point::new(point.longitude, point.latitude)));
        });
        segments.push(TrackSegment { points });
    }
    write_gpx_with_segments(segments, Some("MemoLanes Journey".to_string()), writer)
}

#[auto_context]
pub fn raw_data_csv_to_gpx_file<R: std::io::Read, W: Write + Seek>(
    csv_reader: &mut Reader<R>,
    writer: &mut W,
) -> Result<()> {
    let mut segment = TrackSegment { points: Vec::new() };

    for result in csv_reader.deserialize::<RawCsvRow>() {
        let raw: RawCsvRow = result?;

        let mut wp = Waypoint::new(Point::new(raw.longitude, raw.latitude));

        if let Some(ts) = raw.timestamp_ms {
            if ts > 0 {
                let dt = OffsetDateTime::UNIX_EPOCH + Duration::milliseconds(ts);
                wp.time = Some(dt.into());
            }
        }

        if let Some(alt) = raw.altitude {
            wp.elevation = Some(alt as f64);
        }

        if let Some(acc) = raw.accuracy {
            wp.hdop = Some(acc as f64);
        }

        segment.points.push(wp);
    }
    write_gpx_with_segments(vec![segment], Some("MemoLanes RawData".to_string()), writer)
}

#[auto_context]
pub fn journey_vector_to_kml_file<T: Write + Seek>(
    journey_vector: &JourneyVector,
    writer: &mut T,
) -> Result<()> {
    let style = kml::types::Style {
        ..kml::types::Style::default()
    };

    let mut elements = vec![Kml::Style(style)];

    for track_segment in &journey_vector.track_segments {
        let mut coords = Vec::new();
        let mut gx_coords = Vec::new();
        track_segment.track_points.iter().for_each(|point| {
            coords.push(kml::types::Coord {
                x: point.longitude,
                y: point.latitude,
                z: None,
            });
            gx_coords.push(kml::types::Element {
                name: "gx:coord".to_owned(),
                content: Some(format!("{} {} {}", point.longitude, point.latitude, 0)),
                ..kml::types::Element::default()
            })
        });
        let geometry = kml::types::LineString {
            coords,
            tessellate: true,
            ..kml::types::LineString::default()
        };

        let placemark = kml::types::Placemark {
            name: Some("export".to_string()),
            children: vec![kml::types::Element {
                name: "gx:Track".to_owned(),
                content: None,
                children: gx_coords,
                ..kml::types::Element::default()
            }],
            geometry: Some(kml::types::Geometry::LineString(geometry)),
            ..kml::types::Placemark::default()
        };
        elements.push(kml::Kml::Placemark(placemark))
    }

    write_kml_document(
        "memolanes".to_owned(),
        "Generated by memolanes".to_owned(),
        elements,
        writer,
    )?;
    Ok(())
}

#[auto_context]
fn write_kml_document<T: Write + Seek>(
    name: String,
    description: String,
    elements: Vec<Kml>,
    writer: &mut T,
) -> Result<()> {
    let document = KmlDocument::<f64> {
        version: kml::KmlVersion::V22,
        attrs: HashMap::from([
            (
                "xmlns".to_owned(),
                "http://www.opengis.net/kml/2.2".to_owned(),
            ),
            (
                "xmlns:gx".to_owned(),
                "http://www.google.com/kml/ext/2.2".to_owned(),
            ),
            (
                "xmlns:kml".to_owned(),
                "http://www.opengis.net/kml/2.2".to_owned(),
            ),
            (
                "xmlns:atom".to_owned(),
                "http://www.w3.org/2005/Atom".to_owned(),
            ),
        ]),
        elements: vec![Kml::Folder {
            attrs: HashMap::from([
                ("name".to_owned(), name),
                ("description".to_owned(), description),
            ]),
            elements,
        }],
    };

    let mut writer = KmlWriter::<_, f64>::from_writer(writer);
    let kml = Kml::KmlDocument(document);
    writer.write(&kml)?;
    Ok(())
}
